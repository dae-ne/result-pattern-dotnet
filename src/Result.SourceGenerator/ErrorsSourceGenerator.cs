using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Result.SourceGenerator
{
    [Generator]
    public sealed class ErrorsSourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var errors = context.Compilation.SyntaxTrees
                .SelectMany(tree => tree.GetRoot().DescendantNodes())
                .OfType<ClassDeclarationSyntax>()
                .Where(classDeclaration => classDeclaration.BaseList?.Types
                    .Any(baseType => baseType.Type.ToString() == "ErrorBase") == true)
                .ToList();

            if (errors.Count == 0)
            {
                return;
            }

            // get namespace of each error
            var namespaces = errors
                .Select(error => context.Compilation.GetSemanticModel(error.SyntaxTree).GetDeclaredSymbol(error))
                .Select(error => error?.ContainingNamespace.ToString())
                .Where(ns => ns != null)
                .Distinct()
                .ToList();

            var source = $@"// <auto-generated/>
{string.Join("\n", namespaces.Select(ns => $"using {ns};"))}

namespace Daene.Result.Errors
{{
  public partial class Errors
  {{
{string.Join("\n", errors.Select(error =>
{
    const string suffixToRemove = "Error";
    var errorName = error.Identifier.Text;
    var methodName = errorName.EndsWith(suffixToRemove)
        ? errorName.Substring(0, errorName.Length - suffixToRemove.Length)
        : errorName;
    return $"    public static {errorName} {methodName}(string message) => new {errorName}(message);";
}))}
  }}
}}";
            context.AddSource("Errors.g.cs", source);
        }
    }
}
